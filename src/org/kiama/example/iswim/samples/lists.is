/**
 * Title:       Immutable lists
 * Description: A very simple implementation of immutable lists.
 *              We use the empty value () to represent the empty list
 *              and pairs (_,_) to represent cons cells.
 *
 *              Here we represent functions with multiple parameters in
 *              curried form, as single argument functions whose return
 *              results are themselves function closures. 
 *
 * Copyright:   (C) 2010-2011 Dominic Verity, Macquarie University
 */ 

primitives write;

let writeln = fun(v) { write v; write "\n" }

and car = fun(x) (x match {
    (h,t) -> h
})

and cdr = fun(x) (x match {
    (h,t) -> t
});

letrec isList = fun(x) (x match {
    ()     -> true;
    (y,ys) -> isList ys;
    z      -> false
});

letrec seq = fun(n) fun(m) (if (n <= m) (n, seq (n+1) m) else ());

// A useful function - the right handed fold.
let foldr = fun(a) fun(f) (
    letrec foldAux = fun(ls) (ls match {
        ()      -> a;
        (y,ys)  -> f y (foldAux ys)
    }) in foldAux)

and foldr1 = fun(f) (
    letrec foldAux = fun(ls) (ls match {
        (x,xs) -> (xs match {
            ()      -> x;
            (y,ys)  -> f x (foldAux xs)
        })
    }) in foldAux
)

// and its left handed counterpart
and foldl = fun(f) (
    letrec foldAux = fun(a) fun(ls) (ls match {
        ()      -> a;
        (y,yx)  -> foldAux (f a y) yx
    }) in foldAux
);

let foldl1 = fun(f) fun(ls) (ls match { (y,ys) -> foldl f y ys })

and sum = fun(ls) (foldr 0 (fun(l) fun(r) (l + r)) ls)

and product = fun(ls) (foldr 1 (fun(l) fun(r) (l * r)) ls)

and map = fun(f) fun(ls) (foldr () (fun(l) fun(r) (f l, r)) ls)

and reverse = foldl (fun(x) fun(y) (y,x)) ()

and concat = fun(xs) fun(ys) (foldr ys (fun(a) fun(as) (a,as)) xs)

and length = foldr 0 (fun(x) fun(a) (a + 1))

// The following function allows us to iterate along list in
// the style of the Scala "for" control structure.
and for = fun(ls) fun(f) (
    letrec forAux = fun(xs) (xs match {
        ()      -> ();
        (y,ys)  -> { f y; forAux ys }
    }) in (forAux ls)
);


// Using for we can easily define a function to pretty print
// lists to the terminal
let writeList = fun(ls) {
    write "[";
    ls match {
        () -> ();
        (x,xs) -> {
            write x;
            for xs (fun(y) { write ","; write y })
        }
    };
    write "]"
}; 

let lst1 = seq 4 10;

{
    writeln(isList lst1);
    writeln(sum lst1);
    writeln(sum (map (fun(n) (n*n)) lst1));
    writeln(product lst1);
    writeList lst1;
    write "\n";
    writeList (reverse lst1);
    write "\n";
    writeList (concat (reverse lst1) lst1);
    write "\n";
    writeln (length lst1)
}