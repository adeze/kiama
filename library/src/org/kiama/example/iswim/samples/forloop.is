/**
 * Title:     Code Sample - for loop with continue and break
 * Author:    Dominic Verity
 * Copyright: Macquarie University (C) 2007-2011
 *
 * The following functions implement a for() loop and associated continue()
 * and break() operations.
 *
 * We use 3 continuations here:
 *      top - which marks the top of the loop body. throw to here to iterate.
 *      cnt - which marks the bottom of the loop body, just before the point that
 *            the loop counter is incremented. throw to here to continue.
 *      brk - which marks the point just after the iteration jump, throw to here to break.
 *
 * Here multiple parameter functions are represented in uncurried form, as functions which 
 * expect a single argument which consists of a tuple of argument values. These are then
 * taken apart using the match construct.
 */
 
// Bring some useful primitives into scope
primitives write;

// Package for(), continue() and break() together so that they can have shared
// access to the continue and break continuations.
let forFunctions = 
    let cnt = mkref ()  // ref value to hold the current "continue" continuation.
    and brk = mkref ()  // ref value to hold the current "break" continuation.
                        // these local variables are all in scope in the bodies of the
                        // functions for(), continue() and break() below.
    in let for = fun(args) (args match {
        (start,stop,body) ->
            let top = mkref ()                      // ref value to hold the "top of loop body" continuation.
            and counter = mkref start               // we'll also use a reference for the loop counter.
            and savedcnt = val cnt                  // save the current continue and break continuations
            and savedbrk = val brk                  // in local variables of the for function.
                                                    // now we can change the values contained in these
                                                    // references as we like in the body of the for function,
                                                    // safe in the knowledge that we can restore their
                                                    // original values before we exit that function.
            in {
                callcc(fun(c) {                     // ***** capture continuation for loop exit point *********
                    brk := c;                       //       and make it the current break continuation
                    callcc(fun(c) {                 // ----- capture contunation for next iteration -----------
                        cnt := c;                   //       and make it the current continue continuation
                        callcc(fun(c) top := c);    // ~~~~~~~~~~~~ top of loop body ~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if (stop < (val counter))   // if we've come to the end
                            throw () to (val brk)   // go to the exit point of the loop
                        else (); 
                        body(val counter)           // execute loop body.
                    });                             // ----- throw () to (val cnt) gets us to here ------------
                    counter := (val counter) + 1;   // advance counter and
                    throw () to (val top)           // jump back for next iteration.
                });                                 // ***** throw () to (val brk) gets us to here ************
                cnt := savedcnt;                    // restore original continue and break continuations
                brk := savedbrk                     // from enclosing for loop (if any) and exit.
            }
        })
        and continue = fun(a) (a match {            // now continue() and break() are implemented as jumps to the
            () ->                                   // continue and break continuations (respectively)
                if ((val cnt) != ())                // if we are outside of a for loop then
                    throw () to (val cnt)           // the cnt and brk references will contain () so
                else ()                             // we check for that case.
        })
        and break = fun(a) (a match {
            () ->
                if ((val brk) != ())
                    throw () to (val brk)
                else ()
        })
        in (for,continue,break);
        
// Notice that the variables brk and cnt are not in scope here.
// However the function closures in the triple which we've bound to 
// forFunctions still have shared access to the reference values
// they were bound to when those closures were constructed.

// Again this is just a matter of using closures to hide shared data.
        
let for = forFunctions match { (f,c,b) -> f }
and continue = forFunctions match { (f,c,b) -> c }
and break = forFunctions match { (f,c,b) -> b };

// Now for some tests that this implementation works.   
{
    // Using break and continue in a loop
    for(1,20, fun(n) { 
        if (n == 14) break() else ();
        if (n % 2 == 0) {
            write "an even number\n";
            continue()
        } else ();
        write(n); 
        write "\n" });
        
    // Testing that things work for nested loops
    for(1,20, fun(n) {
        for(1,20, fun(m) {
            if (n < m) break() else ();
            if (m % 3 == 0) continue() else ();
            write "(";
            write n;
            write ",";
            write m;
            write ") "
        });
        write "\n";
        if (n == 17) break() else ();
        if (n % 2 == 0) continue() else ();
        write "wibble wibble wibble!\n"
    })
}

